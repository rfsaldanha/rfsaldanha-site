{
  "hash": "1820c384bfefb778c74035218f9886b5",
  "result": {
    "markdown": "---\ntitle: \"Counting consecutive sequences of events: run length encoding and warm spell occurence example\"\ndate: \"2023-11-06\"\ncategories: [rle, warm spell, sequences]\n---\n\n\nSome days ago I was trying to count how many times consecutive sequences with values higher than a reference appears in a data frame.\n\nFor example:\n\n$x = {2,2,3,4,4,5,6,7,3,7,7,1,6,7,8}$\n\nOn $x$, how many times values higher than four appears in consecutive sequences with three or more elements?\n\nTwo times: the sequences $5,6,7$ and $6,7,8$.\n\nBut how to figure this out with R?\n\n## Run length encoding\n\nBase R has an interesting function called Run Length Encoding: `rle(x)`. Let's see how this works with our example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(2,2,3,4,4,5,6,7,3,7,7,1,6,7,8)\n\nrle(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRun Length Encoding\n  lengths: int [1:12] 2 1 2 1 1 1 1 2 1 1 ...\n  values : num [1:12] 2 3 4 5 6 7 3 7 1 6 ...\n```\n:::\n:::\n\n\nThe `rle` function returns a list of lengths and values. The \"lengths\" says how many times the \"values\" appears. The number two appears two times in sequence, then the number three appears one time, followed by a fours appearing two times, and so on...\n\n## Count consecutive sequences\n\nI created a little function (`trle`) to perform the following task: with a vector `x`, count consecutive sequences of length equal or higher than `l` that contains values equal or higher than `v`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrle <- function(x, l, v){\n  x_logical <- x >= v #<1>\n  \n  rle_list <- rle(x_logical) #<2>\n\n  rle_df <- data.frame(        #<3>\n    length = rle_list$lengths, #<3>\n    value = rle_list$values    #<3>\n  )                            #<3>\n\n  res_df <- subset(rle_df, value == TRUE & length >= l) #<4>\n  \n  res <- nrow(res_df) #<5>\n\n  return(res)         #<5>\n}\n```\n:::\n\n\n1.  Check if each element of `x` is higher or equal to `v`. This will return a vector of true and false values.\n2.  Run the `rle` function over the sequence of true/false values.\n3.  Convert the list in a data frame object.\n4.  Filter rows where the `value` is equal to `TRUE` AND (`&`) have length higher than `l`.\n5.  Count the rows. That's the result!\n\nLet's test it with our example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrle(x, l = 3, v = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\n::: callout-note\nThere are probably better and faster ways to implement this. I focused on being simple and readable.\n:::\n\n## Warm spell example\n\nIn climatology there is an indicator called Warm Spell Duration Index (WSDI). A warm spell consist of at least six consecutive days with maximum temperatures higher than the climatological normal maximum temperature. A more formal definition can be found [here](https://www.climdex.org/learn/indices/#index-WSDI).\n\nWe can get some temperature values with the `brclimr` package for Rio de Janeiro, Brazil.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrio <- brclimr::fetch_data(\n  code_muni = 3304557,\n  product = \"brdwgd\", \n  indicator = \"tmax\", \n  statistics = \"mean\", \n  date_start = as.Date(\"2020-01-01\"),\n  date_end = as.Date(\"2020-12-31\")\n)\n\nhead(rio, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 2\n   date       value\n   <date>     <dbl>\n 1 2020-01-01  36.0\n 2 2020-01-02  31.1\n 3 2020-01-03  27.9\n 4 2020-01-04  28.5\n 5 2020-01-05  28.4\n 6 2020-01-06  34.1\n 7 2020-01-07  35.8\n 8 2020-01-08  32.8\n 9 2020-01-09  33.4\n10 2020-01-10  33.7\n```\n:::\n:::\n\n\nLet's assume the reference value as 30 Celsius degrees. How many sequences of six days or more had temperatures equal or higher than 30?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrle(x = rio$value, l = 6, v = 30)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\nThis happened three times on 2020. Try to find them at the graph bellow:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(scales)\n\nggplot(data = rio, aes(x = date, y = value)) +\n  geom_line(color = \"purple\", alpha = .7) +\n  geom_point(color = \"purple\", alpha = .7) +\n  geom_hline(yintercept = 30, color = \"red\", alpha = .7) +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](run_length_encoding_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n## Length and positions of consecutive events\n\nWould be nice if the function returned also when those sequences happened, right? We can change our little function a little bit to return the dates and actual lengths of those sequences, adding an index vector `i` as argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrle2 <- function(x, i, l, v){\n  x_logical <- x >= v #<1>\n  \n  rle_list <- rle(x_logical) #<2>\n\n  rle_df <- data.frame(        #<3>\n    length = rle_list$lengths, #<3>\n    value = rle_list$values    #<3>\n  )                            #<3>\n\n  rle_df$pos_2 <- cumsum(rle_df$length)            #<4>\n  rle_df$pos_1 <- rle_df$pos_2 - rle_df$length + 1 #<4>\n\n  rle_df <- data.frame(       #<5>\n    pos_1 = i[rle_df$pos_1],  #<5>\n    pos_2 = i[rle_df$pos_2],  #<5>\n    length = rle_df$length,   #<5>\n    value = rle_df$value      #<5>\n  )                           #<5>\n\n  res <- subset(rle_df, value == TRUE & length >= l) #<6>\n  res$value <- NULL     #<7>\n  rownames(res) <- NULL #<8>\n\n  return(res)           #<9>\n}\n```\n:::\n\n\n1.  Check if each element of `x` is higher or equal to `v`. This will return a vector of true and false values.\n2.  Run the `rle` function over the sequence of true/false values.\n3.  Convert the list in a data frame object.\n4.  Establish the start (`pos_1`) and end (`pos_2`) positions of each sequence. The end position is the cumulative sum of the lengths. The start position is equivalent to the end position minus the length plus one.\n5.  Create a data frame with the equivalent positions on the vector `i` and the length and values of the sequences\n6.  Filter rows where the `value` is equal to `TRUE` AND (`&`) have length higher than `l`.\n7.  Remove the `value` variable.\n8.  Remove row names.\n9.  Return the data frame as result.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- trle2(x = rio$value, i = rio$date, l = 6, v = 30)\n\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       pos_1      pos_2 length\n1 2020-01-06 2020-01-12      7\n2 2020-01-26 2020-02-03      9\n3 2020-02-15 2020-02-21      7\n```\n:::\n:::\n\n\nTo see that on the graph, we can use some `lubridate` functions. First, we create a list of date intervals.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lubridate)\n\nintervals <- as.list(lubridate::interval(res$pos_1, res$pos_2))\n```\n:::\n\n\nThen, we check if the dates are within those intervals.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrio$test <- rio$date %within% intervals\n\nhead(rio, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 3\n   date       value test \n   <date>     <dbl> <lgl>\n 1 2020-01-01  36.0 FALSE\n 2 2020-01-02  31.1 FALSE\n 3 2020-01-03  27.9 FALSE\n 4 2020-01-04  28.5 FALSE\n 5 2020-01-05  28.4 FALSE\n 6 2020-01-06  34.1 TRUE \n 7 2020-01-07  35.8 TRUE \n 8 2020-01-08  32.8 TRUE \n 9 2020-01-09  33.4 TRUE \n10 2020-01-10  33.7 TRUE \n```\n:::\n:::\n\n\nAnd plot it!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = rio, aes(x = date, y = value)) +\n  geom_line(color = \"purple\", alpha = .7) +\n  geom_point(aes(color = test), alpha = .7) +\n  geom_hline(yintercept = 30, color = \"red\", alpha = .7) +\n  scale_color_manual(values=c(\"#999999\", \"#E69F00\")) +\n  theme_classic() +\n  theme(legend.position = \"bottom\", legend.direction = \"horizontal\")\n```\n\n::: {.cell-output-display}\n![](run_length_encoding_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n## Session info\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.3 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_CA.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_CA.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_CA.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_CA.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: Europe/Paris\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] lubridate_1.9.3 scales_1.2.1    ggplot2_3.4.4  \n\nloaded via a namespace (and not attached):\n [1] bit_4.0.5         gtable_0.3.4      jsonlite_1.8.7    dplyr_1.1.4      \n [5] compiler_4.3.2    tidyselect_1.2.0  assertthat_0.2.1  arrow_14.0.0     \n [9] yaml_2.3.7        fastmap_1.1.1     R6_2.5.1          labeling_0.4.3   \n[13] generics_0.1.3    brclimr_0.1.2     knitr_1.45        htmlwidgets_1.6.2\n[17] backports_1.4.1   checkmate_2.3.0   tibble_3.2.1      munsell_0.5.0    \n[21] pillar_1.9.0      rlang_1.1.2       utf8_1.2.4        xfun_0.41        \n[25] bit64_4.0.5       timechange_0.2.0  cli_3.6.1         withr_2.5.2      \n[29] magrittr_2.0.3    digest_0.6.33     grid_4.3.2        rstudioapi_0.15.0\n[33] lifecycle_1.0.4   vctrs_0.6.4       evaluate_0.23     glue_1.6.2       \n[37] farver_2.1.1      colorspace_2.1-0  fansi_1.0.5       rmarkdown_2.25   \n[41] purrr_1.0.2       tools_4.3.2       pkgconfig_2.0.3   htmltools_0.5.7  \n```\n:::\n:::\n",
    "supporting": [
      "run_length_encoding_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}