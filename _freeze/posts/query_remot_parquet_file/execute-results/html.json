{
  "hash": "6d21a61116ab952f14a963c062e2aec7",
  "result": {
    "markdown": "---\ntitle: \"Query remote parquet files with DuckDB\"\ndate: \"2023-10-24\"\ncategories: [database, duckdb, parquet]\n---\n\n\nDuckDB has a very interesting extension called [httpfs](https://duckdb.org/docs/extensions/httpfs.html) that allows to query CSV and parquet files remotely, including S3 storage.\n\nI will gave here an example about how to query a parquet file stored in a GitHub repository release.\n\n## Remote parquet file\n\nFirst, I recommend to create an object with the URL of the parquet file. On the example bellow, the parquet file contains the `nycflights13` flights database.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparquet_url <- \"https://github.com/rfsaldanha/releases/releases/download/v1/flights.parquet\"\n```\n:::\n\n\nThis is a real URL. If you try to open it with your browser, a download will start.\n\n## DuckDB database on memory\n\nNext, we create a DuckDB connection. Considering that the data is stored remotely, we can create this DuckDB database on memory and not on disk.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconn <- DBI::dbConnect(\n  duckdb::duckdb(),\n  dbdir = \":memory:\"\n)\n```\n:::\n\n\n## httpfs extension\n\nNow, we need to load the `httpfs` extension.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDBI::dbExecute(conn, \"INSTALL httpfs;\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\nDBI::dbExecute(conn, \"LOAD httpfs;\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\n::: callout-warning\n## Windows users\n\nThe last time I checked, the `httpfs` extension was not working on Windows.\n:::\n\n## Query\n\nWe are ready to execute a query over the parquet file!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- DBI::dbGetQuery(\n  conn, \n  glue::glue(\"SELECT carrier, flight, tailnum, year FROM '{parquet_url}' WHERE year = 2013 LIMIT 100\")\n)\n\ndplyr::glimpse(res)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 100\nColumns: 4\n$ carrier <chr> \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"AA\", \"B…\n$ flight  <int> 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 49, 71, …\n$ tailnum <chr> \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N39463\", \"N…\n$ year    <int> 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 20…\n```\n:::\n:::\n\n\nThis query selects some variables and filter the year, returning the first 100 rows. The query is carried out by DuckDB accessing the remote parquet file, but the file is not downloaded. That's great!!\n\n::: callout-tip\nQueries that needs more data and return more rows takes longer to run, especially transmitting data over the Internet. Craft carefully your queries with this in mind.\n:::\n\nIf you want to use `dplyr` verbs with the connection, you can create a view query.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDBI::dbExecute(conn, glue::glue(\"CREATE VIEW flights AS SELECT * FROM PARQUET_SCAN('{parquet_url}')\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nDBI::dbListTables(conn)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"flights\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\ntbl(conn, \"flights\") %>%\n  group_by(month) %>%\n  summarise(freq = n()) %>%\n  ungroup() %>%\n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 × 2\n   month  freq\n   <int> <dbl>\n 1     1 27004\n 2     2 24951\n 3     3 28834\n 4     4 28330\n 5     5 28796\n 6     6 28243\n 7     7 29425\n 8     8 29327\n 9     9 27574\n10    10 28889\n11    11 27268\n12    12 28135\n```\n:::\n:::\n\n\nNow we can close the connection.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDBI::dbDisconnect(conn, shutdown = TRUE)\n```\n:::\n\n\n## Extra: `duckdbfs` package\n\nThe [duckdbfs](https://cboettig.github.io/duckdbfs/) offers a neat way to connect to remote parquet files and other connections. The same example using the package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nds <- duckdbfs::open_dataset(parquet_url)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nds %>%\n  group_by(month) %>%\n  summarise(freq = n()) %>%\n  ungroup() %>%\n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 × 2\n   month  freq\n   <int> <dbl>\n 1     1 27004\n 2     2 24951\n 3     3 28834\n 4     4 28330\n 5     5 28796\n 6     6 28243\n 7     7 29425\n 8     8 29327\n 9     9 27574\n10    10 28889\n11    11 27268\n12    12 28135\n```\n:::\n:::\n\n\n## Session info\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.3 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_CA.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_CA.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_CA.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_CA.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: Europe/Paris\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] dplyr_1.1.3\n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.4       cli_3.6.1         knitr_1.45        rlang_1.1.2      \n [5] xfun_0.41         DBI_1.1.3         purrr_1.0.2       duckdbfs_0.0.3   \n [9] generics_0.1.3    jsonlite_1.8.7    glue_1.6.2        dbplyr_2.4.0     \n[13] htmltools_0.5.7   fansi_1.0.5       rmarkdown_2.25    evaluate_0.23    \n[17] tibble_3.2.1      fastmap_1.1.1     yaml_2.3.7        lifecycle_1.0.3  \n[21] duckdb_0.9.1-1    compiler_4.3.2    blob_1.2.4        htmlwidgets_1.6.2\n[25] pkgconfig_2.0.3   rstudioapi_0.15.0 digest_0.6.33     R6_2.5.1         \n[29] tidyselect_1.2.0  utf8_1.2.4        pillar_1.9.0      magrittr_2.0.3   \n[33] tools_4.3.2      \n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}