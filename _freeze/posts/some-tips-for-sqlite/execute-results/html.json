{
  "hash": "fb33f5485fa8c2a438528968faa46baa",
  "result": {
    "markdown": "---\ntitle: \"Some tips to work with SQLite database\"\ndate: \"2023-10-19\"\ncategories: [database, sqlite]\n---\n\n\nSQLite database are very popular and make a great job for its simplicity and practicity. I have been using it for a while and would like to organize some tips.\n\n## Dates and extended types\n\nNatively, SQLite databases does not handle dates.\n\nLet's create and example with some data from flights\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(lubridate)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'lubridate'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(DBI)\nlibrary(nycflights13)\n\nflights <- flights %>% \n  select(year, month, day, hour, minute) %>% \n  mutate(departure = make_date(year, month, day))\n\nhead(flights)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n   year month   day  hour minute departure \n  <int> <int> <int> <dbl>  <dbl> <date>    \n1  2013     1     1     5     15 2013-01-01\n2  2013     1     1     5     29 2013-01-01\n3  2013     1     1     5     40 2013-01-01\n4  2013     1     1     5     45 2013-01-01\n5  2013     1     1     6      0 2013-01-01\n6  2013     1     1     5     58 2013-01-01\n```\n:::\n:::\n\nThe data is ready to store at the database.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatabase_file <- tempfile()\n\nconn <- dbConnect(RSQLite::SQLite(), database_file)\n\ndbWriteTable(conn, name = \"flights_table\", value = flights)\n```\n:::\n\n\nLet's take a look how the data was stored.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(conn, \"flights_table\") %>% head() %>% collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n   year month   day  hour minute departure\n  <int> <int> <int> <dbl>  <dbl>     <dbl>\n1  2013     1     1     5     15     15706\n2  2013     1     1     5     29     15706\n3  2013     1     1     5     40     15706\n4  2013     1     1     5     45     15706\n5  2013     1     1     6      0     15706\n6  2013     1     1     5     58     15706\n```\n:::\n:::\n\nThe departure variable seems a confusing text. But we have a savior called `extended_types`.\n\nFirst, lets close the connection with the database.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbDisconnect(conn)\n```\n:::\n\n\nAnd recreate the table with a new connection\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconn2 <- dbConnect(RSQLite::SQLite(), database_file, extended_types = TRUE)\ndbWriteTable(conn2, name = \"flights_table\", value = flights, overwrite = TRUE)\n```\n:::\n\n\nLet's see the difference...\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(conn2, \"flights_table\") %>% head() %>% collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n   year month   day  hour minute departure \n  <int> <int> <int> <dbl>  <dbl> <date>    \n1  2013     1     1     5     15 2013-01-01\n2  2013     1     1     5     29 2013-01-01\n3  2013     1     1     5     40 2013-01-01\n4  2013     1     1     5     45 2013-01-01\n5  2013     1     1     6      0 2013-01-01\n6  2013     1     1     5     58 2013-01-01\n```\n:::\n:::\n\n\nAnd voilà! We have the dates.\n\nBut if you need to store this variable as character with a human readable value? There is a trick.\n\nFirst, you need to create a temporary table with the same schema but the date as `varchar`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbExecute(conn2, \"CREATE TABLE 'flights_table_2'(year bigint, month bigint, day bigint, hour float, minute float, departure varchar)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\nAnd then copy the data from the original table to this empty table.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbExecute(conn2, \"INSERT INTO 'flights_table_2' SELECT year, month, day, hour, minute, strftime('%Y-%m-%d', departure*24*60*60, 'unixepoch') FROM 'flights_table'\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 336776\n```\n:::\n:::\n\n\nLet's see the new table\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(conn2, \"flights_table_2\") %>% head() %>% collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n   year month   day  hour minute departure \n  <int> <int> <int> <dbl>  <dbl> <chr>     \n1  2013     1     1     5     15 2013-01-01\n2  2013     1     1     5     29 2013-01-01\n3  2013     1     1     5     40 2013-01-01\n4  2013     1     1     5     45 2013-01-01\n5  2013     1     1     6      0 2013-01-01\n6  2013     1     1     5     58 2013-01-01\n```\n:::\n:::\n\nThat's it! Let's close the connection, its a good practice.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbDisconnect(conn2)\n```\n:::\n\n\n\n\n## Parallel write\n\nOne nice thing about databases is parallel writing. Imagine a function being executed by various processor workers and writing the results at the same database and even at the same table.\n\nThere are some nice tricks to allow it with SQLite. Basically, those are the options that I use.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconn <- DBI::dbConnect(RSQLite::SQLite(), database_file, extended_types = TRUE, synchronous = NULL)\ndbExecute(conn, \"PRAGMA busy_timeout = 5000\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\ndbExecute(conn, \"BEGIN IMMEDIATE TRANSACTION\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\ndbWriteTable(conn = conn, name = \"flights_table\", value = flights, append = TRUE)\ndbExecute(conn, \"COMMIT TRANSACTION\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\ndbDisconnect(conn)\n```\n:::\n\n\nBasically, if you use these commands in a function to be executed in parallel, you should not have problems with concurrent writes. \n\n## Delete table\n\nOne odd thing, after you delete a table in a database you need to vacuum it to get the free space.\n\nLets delete the file database and do some testing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunlink(database_file)\n```\n:::\n\n\nWe will create the database with two equal tables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconn <- dbConnect(RSQLite::SQLite(), database_file, extended_types = TRUE)\ndbWriteTable(conn = conn, name = \"flights_table_1\", value = flights)\ndbWriteTable(conn = conn, name = \"flights_table_2\", value = flights)\ndbDisconnect(conn)\n```\n:::\n\n\nWhat's is the size of the file?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfs::file_size(database_file)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n13.4M\n```\n:::\n:::\n\n\nNow, lets delete one of the tables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconn <- dbConnect(RSQLite::SQLite(), database_file, extended_types = TRUE)\ndbRemoveTable(conn = conn, name = \"flights_table_1\")\ndbDisconnect(conn)\n\nfs::file_size(database_file)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n13.4M\n```\n:::\n:::\n\nSame size... so, lets vacuum it!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconn <- dbConnect(RSQLite::SQLite(), database_file, extended_types = TRUE)\ndbExecute(conn, \"VACUUM;\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\ndbDisconnect(conn)\n\nfs::file_size(database_file)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6.69M\n```\n:::\n:::\n\n\nAnd whe have a smaller size!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}