{
  "hash": "1651efa89bdd3abc5c7a764ede68ad47",
  "result": {
    "markdown": "---\ntitle: \"Some tips to work with SQLite database\"\ndate: \"2023-10-19\"\ncategories: [database, sqlite]\n---\n\n\nDatabases are very useful for handling large-than-memory datasets, a common problem in Data Science. Several database engines work very well with R and Posit has a nice [guide overview](https://solutions.posit.co/connections/db/) of them.\n\n[SQLite](https://www.sqlite.org/index.html) is a very popular engine due its simplicity. You do not need to install a database server on your environment because SQLite stores the database in a simple single file that you can modify, copy, store at Google Drive etc.\n\nI have been using it for some time and collected some practical tips for some practical situations.\n\nFirst, lets have some data to use at the examples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(nycflights13)\n\nflights <- flights %>% \n  select(year, month, day, hour, minute) %>% \n  mutate(departure = make_date(year, month, day))\n\nglimpse(flights)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 336,776\nColumns: 6\n$ year      <int> 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, …\n$ month     <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n$ day       <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n$ hour      <dbl> 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6, 6, …\n$ minute    <dbl> 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0, 0, …\n$ departure <date> 2013-01-01, 2013-01-01, 2013-01-01, 2013-01-01, 2013-01-01,…\n```\n:::\n:::\n\n\nI specifically created a variable called `departure` to have a date type on our example dataset.\n\n## Dates\n\nNatively, SQLite databases does not handle dates and this may be difficult in the beginning. Let's explore some options to handle dates with SQLite.\n\nFirst, we need to create a database in a temporary file using two packages: `DBI` and `RSQLite`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DBI)\nlibrary(RSQLite)\n\ndatabase_file <- tempfile()\nconn <- dbConnect(RSQLite::SQLite(), database_file)\n```\n:::\n\n\nObserve that the `conn` object is NOT the database, is just a connection instruction to the database stored in a file.\n\nLets write the `flights` tibble to the database.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbWriteTable(conn, name = \"flights_table\", value = flights)\n```\n:::\n\n\nNow, let's take a look how the tibble was stored.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(conn, \"flights_table\") %>%\n  head() %>% \n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n   year month   day  hour minute departure\n  <int> <int> <int> <dbl>  <dbl>     <dbl>\n1  2013     1     1     5     15     15706\n2  2013     1     1     5     29     15706\n3  2013     1     1     5     40     15706\n4  2013     1     1     5     45     15706\n5  2013     1     1     6      0     15706\n6  2013     1     1     5     58     15706\n```\n:::\n:::\n\n\nThe departure variable is no more a human-readable date, it is now a integer value in Unix time. That means: \"the number of seconds since 1970-01-01 00:00:00 UTC\". Now very practical...\n\nThus, there as two options for this: you may convert your date variable to a string variable (`as.character(...)`) or use an argument called [`extended_types`](https://rsqlite.r-dbi.org/reference/sqlite) with the `dbConnect` command.\n\nIf you store the date variable as string, you will need to reconvert it to date wherever your collect data from your database, what is not very practical. Let's see how the `extented_types` option works.\n\nFirst, let's close our connection.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbDisconnect(conn)\n```\n:::\n\n\nWe will modify our connection using this argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconn <- dbConnect(RSQLite::SQLite(), database_file, extended_types = TRUE)\n```\n:::\n\n\nAnd now we will overwrite the data at the same table.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbWriteTable(conn, name = \"flights_table\", value = flights, overwrite = TRUE)\n```\n:::\n\n\nLet's see the result.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(conn, \"flights_table\") %>% head() %>% collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n   year month   day  hour minute departure \n  <int> <int> <int> <dbl>  <dbl> <date>    \n1  2013     1     1     5     15 2013-01-01\n2  2013     1     1     5     29 2013-01-01\n3  2013     1     1     5     40 2013-01-01\n4  2013     1     1     5     45 2013-01-01\n5  2013     1     1     6      0 2013-01-01\n6  2013     1     1     5     58 2013-01-01\n```\n:::\n:::\n\n\nVoilà! Now we can now see human-readable dates with a UNIX time variable.\n\n## Parallel write\n\nOne nice thing about databases is parallel writing. Imagine a [function being executed in parallel](https://furrr.futureverse.org) and writing the results at the same database and even at the same table.\n\nThere are some nice tricks to allow it with SQLite. Basically, those are the options that I use.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconn <- DBI::dbConnect(RSQLite::SQLite(), database_file, extended_types = TRUE, synchronous = NULL)\ndbExecute(conn, \"PRAGMA busy_timeout = 5000\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\ndbExecute(conn, \"BEGIN IMMEDIATE TRANSACTION\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\ndbWriteTable(conn = conn, name = \"flights_table\", value = flights, append = TRUE)\ndbExecute(conn, \"COMMIT TRANSACTION\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\ndbDisconnect(conn)\n```\n:::\n\n\nThese options will secure that your connection waits other connections to conclude and immediately [commit](https://en.wikipedia.org/wiki/Commit_(data_management)) the transaction to the database.\n\n## Delete table\n\nOne odd thing, after you delete a table in a database you need to vacuum it to get the free space.\n\nLets delete the file database and do some testing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunlink(database_file)\n```\n:::\n\n\nWe will create the database with two equal tables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconn <- dbConnect(RSQLite::SQLite(), database_file, extended_types = TRUE)\ndbWriteTable(conn = conn, name = \"flights_table_1\", value = flights)\ndbWriteTable(conn = conn, name = \"flights_table_2\", value = flights)\ndbDisconnect(conn)\n```\n:::\n\n\nWhat's is the size of the file?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfs::file_size(database_file)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n13.4M\n```\n:::\n:::\n\n\nNow, lets delete one of the tables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconn <- dbConnect(RSQLite::SQLite(), database_file, extended_types = TRUE)\ndbRemoveTable(conn = conn, name = \"flights_table_1\")\ndbDisconnect(conn)\n\nfs::file_size(database_file)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n13.4M\n```\n:::\n:::\n\n\nSame size... so, lets vacuum it!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconn <- dbConnect(RSQLite::SQLite(), database_file, extended_types = TRUE)\ndbExecute(conn, \"VACUUM;\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\ndbDisconnect(conn)\n\nfs::file_size(database_file)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6.69M\n```\n:::\n:::\n\n\nAnd we have a smaller size!\n\n## Session info\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.2.0 (2022-04-22)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS 14.0\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] RSQLite_2.3.1      DBI_1.1.3          nycflights13_1.0.2 lubridate_1.9.3   \n[5] dplyr_1.1.3       \n\nloaded via a namespace (and not attached):\n [1] pillar_1.9.0      compiler_4.2.0    dbplyr_2.3.4      tools_4.2.0      \n [5] digest_0.6.33     bit_4.0.5         jsonlite_1.8.7    evaluate_0.22    \n [9] memoise_2.0.1     lifecycle_1.0.3   tibble_3.2.1      timechange_0.2.0 \n[13] pkgconfig_2.0.3   rlang_1.1.1       cli_3.6.1         rstudioapi_0.15.0\n[17] yaml_2.3.7        xfun_0.40         fastmap_1.1.1     withr_2.5.1      \n[21] knitr_1.44        fs_1.6.3          hms_1.1.3         generics_0.1.3   \n[25] vctrs_0.6.4       htmlwidgets_1.6.2 bit64_4.0.5       tidyselect_1.2.0 \n[29] glue_1.6.2        R6_2.5.1          fansi_1.0.5       rmarkdown_2.25   \n[33] purrr_1.0.2       blob_1.2.4        magrittr_2.0.3    htmltools_0.5.6.1\n[37] utf8_1.2.3        cachem_1.0.8     \n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}